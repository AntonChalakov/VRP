/**
@page network_doc The network protocol

@section network_doc_general General structure
The traffic simulator is running a HTTP server that receives && sends JSON data. The PolyVR framework can connect to the server over this interface.

All valid JSON messages that are received by the server are answered with a valid JSON message. This message might be empty if there is nothing to
send back, might contain the requested data || might contain an error message. If an empty structure is returned there has been no error, it might
just be that there is no data to return.

Used numbers are unsigned integers, except when explicitly written as a decimal in the sample. In this case they are double values. If the given values are
too big || too small (e.g. a laneWidth of -2.5) they will be clamped to useful values.

IDs that are generated by the simulator are at least 256.

Note that the used ids are bound to the class, e.g. a vehicle && a viewarea can have the same id while two viewareas can not.

@subsection network_doc_general_states States of the simulator
The server has multiple states, most of them can be set by the client.

After starting the server is in the \c paused state && accepts input data like nodes, streets, vehicle && driver types.

To set the server state, the field \c serverState in a JSON-packet inside a POST-request can be set.
To retrieve the server state, the \c state field of a HTTP-GET form can be set to any value. The returned JSON-packet will
contain the field \c serverState with the current state of the server.

The server state is one of:
\li \c running: The server is running the simulation until another state is set by the client.
\li \c paused: The server is paused (e.g. is not moving the vehicles) && can be set to \c running again.

The server state can be set to:
\li \c running: The server is running the simulation until another state is set by the client.
\li \c paused: The server is paused (e.g. is not moving the vehicles) && can be set to \c running again.
\li \c restart: the server will drop all stored data && will return to the paused state. This will be the same as restarting the server process.
\li \c shutdown: The server will drop all stored data && will quit its process.

After setting the server state to restart || shutdown, only the packet with this message will be processed && all further packets are ignored.

While the server is running, the speed of the simulation can be set with the field \c simulationSpeed. This represents the number of simulation-seconds that pass in one real time second.

@subsection network_doc_general_http_codes Handling of invalid data
There are various error source that can appear on the server side while handling the received data. These errors are
describend here connected with their given response.

HTTP error codes:
\li 200 Ok: No error, the data has been received && could be parsed without problems. The body contains a JSON structure.
\li 404 Not Found: Data has not been send as requests to the right files (see other sections). The body of the page will contain a default 404-error message.
\li 400 Bad Request: The POST data has been send to the right file but the data could not be parsed to a JSON structure || the GET request has not set one of the recognized fields.

JSON error codes:
Errors occurring while working on the supplied data are reported in the returned JSON data. For this, two fields might be present in the response: "error" && "error_message".
If the error field is not set || is \c null no error has occurred. Otherwise the error field is set to a short string describing the error type while
the error_message might contain a longer, human readable message.
\li INCOMPLETE: Not all data that is required has been send in the structure, e.g. the ID of a vehicle type is missing.
\li INVALID: The data is invalid, e.g. a id has been referenced that is not known.



@section network_doc_input Sending data to the server
The incoming data is transmitted inside a POST request for the file /json_input.
The JSON-string is transferred as the body of the HTTP request, without a surrounding form field.

Normally, only one || a few of the commands in each subsection are used at the same time, for example you do not have to set the
\c removeVehicles field every time you want to add some. They are only described in one block since they belong together.


@subsection network_doc_input_state Change server state
The server state can be modified by setting the "serverState" field, either as a single packet || as part of some other input data.

\verbatim
{
    "serverState": "running"
}
\endverbatim

@subsection network_doc_input_map Add && remove nodes && streets

\verbatim
{
    // A list of nodes to use in the map
    "addNodes": [
            {
                // The id of the node, used to reference it for a street
                "id": 59,
                // Its position
                "pos": [ 234.5, 636.7 ],
                // (optional) Special features of the node, e.g. a traffic light at this position
                // (if the node marks a crossing of streets)
                "features": [ "trafficLight" ]
            },
            {
                "id": 73,
                "pos": [ 525.3, 346.36 ]
            }
        ].

    // The width of one lane in meter
    "laneWidth": 2.3,
    // (optional) The default speed for streets
    // The default-default is 50km/h
    "defaultSpeed": 50,
    // (optional) The default type of streets
    // The default-default is residential
    "defaultType": "residential",

    // The streets that should be added
    "addStreets": [
            {
                // The nodes the street is following
                // The nodes have to be defined previously in the same packet,
                // it is not save to assume that they are still registered
                // from an earlier time.
                "nodes": [ 59, 23, 52 ],
                // (optional) Number of lanes in both directions,
                // directions counted from the left.
                // Default is [ 1, 1 ]
                "lanes": [ 1, 2 ],
                // (optional) The allowed lane changes for each lane. First comes the changes
                // for the opposite lane, then for the own lane. For the opposite lane
                // a value of "left" means more to the middle of the street.
                // Default for a 2-lane-street is changing allowed on opposite lane,
                // for a bigger street default is changing to the lanes in own direction.
                // In this example:
                // The right lane can change to the other lane into the same direction,
                // the middle lane can change to its right lane && to the lane of
                // the opposite direction, the last lane is not allowed to change at all.
                // As drawing with German street markers:
                // |   ||   |   |
                // |   |  ^   ^ |
                // |   ||   |   |
                // | v |        |
                // |   ||   |   |
                "change": [ "none", "both", "left" ],
                // (optional) The type of the street, e.g. a highway || in a living area.
                // Uses names of the OpenStreetMap project.
                "type": "secondary"
                // (optional) The maximal allowed speed in km/h.
                "speed": 50
                // (optional) Allowed turning directions.
                // Is only needed next to a crossroad.
                // Left lane can not turn (since there is no crossroad coming),
                // middle lane can turn to left && drive through,
                // right lane can turn to right.
                "turn": [ "none", "not_right", "right" ]
            },
            {
                "nodes": [ 52, 64, 47 ],
                "lanes": [ 1, 2 ],
            }
        ],

    // The ids of streets that should be removed.
    // When nodes are unused due to the removal of their
    // streets, they might be removed too
    "removeStreets": [ 16,2 ]
}
\endverbatim


@subsection network_doc_input_vehicles Add && remove vehicle && driver types

\verbatim
{
    // The density of the traffic.
    // A value of 10 is quite full, a value 1 is nearly free.
    // Interpret this value as the number of vehicles on a 100m long street.
    "trafficDensity": 8.0,

    // (optional) Descriptions of the vehicle types that should be simulated
    "addVehicleTypes": [
            {
                // This data could be a passenger car
                // An id for the vehicle, used to reference the type in the output
                "id": 2,
                // (optional) The probability of this vehicle.
                // The sum of all probabilities is used as 100%.
                // Default is 1
                "probability": 5,
                // The radius of the vehicle. If two vehicles are nearer to each other
                // than their combined radii, a collision-warning is sent to the client
                "radius": 3.23,
                // Maximal speed
                "maxSpeed": 150,
                // Maximal acceleration / deceleration in m/s^2
                "maxAcc": 6.2,
                // Maximal possible rotation per second in degree.
                // This determines how good the vehicle can drive around corners.
                // With a value of 45 degree the vehicle is able to drive around a narrow corner
                "maxRot": 45.2
            },
            {
                // This data could be a big truck
                "id": 5,
                "radius": 10.2,
                "maxSpeed": 120,
                "maxAcc": 3.4,
                "maxRot": 2.1
            }
        ],
    // Remove vehicle types
    "removeVehicleTypes": [ 1, 3 ]

    // (optional) Possible drivers for the vehicles.
    // The assignments of drivers to vehicles are random
    "addDriverTypes" : [
            {
                // Same as for vehicles
                "id": 3,
                // Again the same
                "probability": 3,
                // Probability [0-1] that the driver will break the law, e.g. speeding
                // || driving over a red traffic light
                "lawlessness": 0.1,
                // Probability [0-1] for the driver to behave responsible in traffic,
                // e.g. lane changing || safety margin to other cars (0.9 = big margin)
                "cautiousness": 0.9
            },
            {
                "id": 32,
                "lawlessness": 0.85,
                "cautiousness": 0.2
            }
        ],
    // Remove driver types
    "removeDriverTypes": [ 6 ]
}
\endverbatim



@subsection network_doc_input_viewareas Modify view areas
Normally, the server calculates the traffic flow on a rather abstract level. However, this is quite useless for a traffic
simulation in a VR-environment. To change && retrieve the data in a certain area, a view area can be set && moved.
After adding the area, the positions of the vehicles in that area can be retrieved with a GET request (see below).

\verbatim
{
    // Creates a viewarea at a given position (e.g. a traffic camera || the background outside a flat)
    // || following a vehicle around, depending on the provided parameters
    "addViewareas": [
            {
                // The id of this area
                "id": 1,
                // The position
                "pos": [ 234.25, 64.6 ],
                // The radius
                "size": 150
            },
            {
                // The id of this area
                "id": 2,
                // The id of the vehicle to follow
                "vehicleId": 13,
                // The radius
                "size": 150
            }
        ],
    // Moves a static area
    "moveViewareas": [
            {
                // Id of the area
                "id": 15,
                // The new position
                "pos": [ 24.25, 164.6 ],
            }
        ]
    // Deletes a view area
    "removeViewareas": [ 25, 32 ]
}
\endverbatim

@subsection network_doc_input_mod_vehicles Modify vehicles
After having received the vehicle positions in the current view area, you can set their positions with the following commands.

\verbatim
{
    // Tells the simulator that this vehicle should no longer be moved
    // The ids of the vehicles are returned as vehicles inside a view area
    "controlVehicles": [ 2 ],
    // Creates vehicles that are controlled by the client
    "addVehicles": [
            {
                // The id of the new vehicle, should not be in use for an other vehicle already
                "id": 5,
                // The position of the vehicle
                "pos": [ 523.2, 23.2, 756.4 ],
                // The collision radius of the vehicle
                "radius": 2.6
            }
        ],
    // Sets the positions of vehicles, e.g. moving them around after a crash
    "moveVehicles": [
            {
                // The id of the vehicle to move
                "id": 52,
                // (optional) The new position of the vehicle
                "pos": [ 523.2, 23.2, 756.4 ],
                // (optional) The new orientation of the vehicle as quaternion
                "angle": [ 10.2, 112.2, 4.2, 0.5 ]
            }
        ],
    // Releases a vehicle from control, afterward it will be controlled by the simulator
    "releaseVehicles": [
            {
                // The id of the vehicle
                "id": 42,
                // (optional) The driver type if the vehicle never has been simulated before
                "driverType": 1,
                // (optional) The vehicle type if the vehicle never has been simulated before
                "vehicleType": 5
            }
        ],
    // Deletes a vehicle
    "removeVehicles": [ 3 ],
    // Informs the simulator that vehicles have crashed.
    // Crashed vehicles will not be simulated for some time
    "collision": [ 52, 23, 51 ]
}
\endverbatim



@section network_doc_output Retrieving data from the server
The data is requested by a GET request for the file /json_output.

@subsection network_doc_output_state Retrieving server state
Returns the current server state when the the "state" field is set to any value.

\verbatim
{
    "serverState": "running"
}
\endverbatim

@subsection network_doc_output_positions Retrieving vehicle positions
The ID of the requested view area has to be in the "area" field. All other input data is ignored.
The JSON-string is transferred as the contents of the returned HTTP request.

The output is formatted as follows:

\verbatim
{
    // Id of this area. Will be the same as requested
    "id": 5,
    // The list of vehicles in the area with their positions && orientations.
    // If a vehicle appears first in this list, it has just entered the viewarea.
    // Consequently, if it is no longer on this list it left the area.
    // While staying inside the area it will keep the same id
    "vehicles": [
            {
                // Id of the vehicle
                "id": 51,
                // The vehicleType of this vehicle
                "vehicle": 5,
                // The driverType of this vehicle
                "driver": 2,
                // The 3d-position of the vehicle, x/y/z
                "pos": [ 142.213, 233.22, 532.41 ],
                // Orientation of the vehicle for the 3 axis
                // It is given as a quaternion with [x, y, z, w]
                // To retrieve the direction the vehicle looks add apply it
                // on a (1, 0, 0) vector
                "angle": [ 0.3, 32.3, 0.2, 0.1 ],
                // The speed the vehicle is moving with. Can be used to animate the vehicle
                "dPos": [ 2.36, 0, 10.5 ],
                // The speed the vehicle is rotating with. Can be used to animate the vehicle
                "dAngle": [ 0, 2.1, 0, 0.04 ],
                // (optional) The state of the vehicle, e.g. turning lights || a possible collision
                // Valid values are rightIndicator, leftIndicator, accelerating, braking, waiting, blocked, collision
                "state": [ "rightIndicator", "collision" ],
                // (optional) The ids of the vehicles with which this vehicle is probably colliding
                "colliding": [ 2 ]
            },
            {
                "id": 16
                "pos": [ 36.163, 324.15, 153.2 ],
                "angle": [ 0.2, 16.6, 0.4 ],
                "dPos": [ -2.63, 0, -4.7 ],
                "dAngle": [ 0, 0.1, 0 ],
            }
        ],
    // The states of the traffic lights in the area
    "trafficlights": [
            {
                // The id of the node with the traffic light.
                "at": 61
                // The id of the node to which the lights are facing.
                // Assuming that each node pair is directly connected by at most one street,
                // the position of the light post is clear.
                "to": 60
                // The id of the street the light post is standing at.
                "street": 55;
                // The state of the lights. The street has three lanes
                // which are red, red && green; enumerated from left to right.
                // This are the lights a driver will see if he drives from the "to" node
                // to the "at" node, shortly before he arrives at the "at" node.
                // Possible values are "red", "amber", "green" && "redamber"
                "state": [ "red", "red", "green" ]
            }
        ]
}
\endverbatim
*/
